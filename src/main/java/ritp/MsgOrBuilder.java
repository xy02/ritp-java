// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ritp.proto

package ritp;

public interface MsgOrBuilder extends
    // @@protoc_insertion_point(interface_extends:ritp.Msg)
    com.google.protobuf.MessageLiteOrBuilder {

  /**
   * <pre>
   *流ID
   * </pre>
   *
   * <code>uint32 stream_id = 1;</code>
   * @return The streamId.
   */
  int getStreamId();

  /**
   * <pre>
   *流数据头，发送一条此数据开始一条流，本端Producer生产数据，对端Consumer消费数据
   * </pre>
   *
   * <code>.ritp.Header header = 2;</code>
   * @return Whether the header field is set.
   */
  boolean hasHeader();
  /**
   * <pre>
   *流数据头，发送一条此数据开始一条流，本端Producer生产数据，对端Consumer消费数据
   * </pre>
   *
   * <code>.ritp.Header header = 2;</code>
   * @return The header.
   */
  Header getHeader();

  /**
   * <pre>
   *Consumer关闭流，不再接收流数据
   * </pre>
   *
   * <code>.ritp.Close close = 3;</code>
   * @return Whether the close field is set.
   */
  boolean hasClose();
  /**
   * <pre>
   *Consumer关闭流，不再接收流数据
   * </pre>
   *
   * <code>.ritp.Close close = 3;</code>
   * @return The close.
   */
  Close getClose();

  /**
   * <pre>
   *表示Consumer可以接收更多的buf的个数，等同于ReactiveStream里request(n)的意义
   *生产者Producer发送的buf总个数必须小于等于消费者Consumer发送的pull的累加总和
   * </pre>
   *
   * <code>uint32 pull = 4;</code>
   * @return The pull.
   */
  int getPull();

  /**
   * <pre>
   *Producer发送流数据，只有收到对端Consumer发送的pull后，本端才能发送有限个数的buf
   * </pre>
   *
   * <code>bytes buf = 5;</code>
   * @return The buf.
   */
  com.google.protobuf.ByteString getBuf();

  /**
   * <pre>
   *Producer结束流
   * </pre>
   *
   * <code>.ritp.End end = 6;</code>
   * @return Whether the end field is set.
   */
  boolean hasEnd();
  /**
   * <pre>
   *Producer结束流
   * </pre>
   *
   * <code>.ritp.End end = 6;</code>
   * @return The end.
   */
  End getEnd();

  public Msg.TypeCase getTypeCase();
}
